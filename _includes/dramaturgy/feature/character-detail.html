{% comment %}
Character Detail Modal
Shows detailed information about a character when clicked
{% endcomment %}

<script>
// Character detail modal functionality
let characterModal = null; // Store modal instance globally

function openCharacterModal(characterName) {
    const character = dd_characters.find(c => c.name === characterName);
    if (!character) {
        console.error('Character not found:', characterName);
        return;
    }
    
    // Get additional character data from CSV if available
    const csvData = getCharacterCSVData(characterName);
    
    // Calculate character connections
    const connections = calculateCharacterConnections(character);
    const connectionsByStrength = categorizeConnections(connections);
    
    // Get scene analysis
    const sceneAnalysis = analyzeCharacterScenes(character);
    
    // Populate modal content
    const modalContent = document.getElementById('characterDetailContent');
    if (modalContent) {
        modalContent.innerHTML = generateCharacterDetailHTML(character, csvData, connections, connectionsByStrength, sceneAnalysis);
    }
    
    // Update modal title
    const modalTitle = document.getElementById('characterDetailModalLabel');
    if (modalTitle) {
        modalTitle.textContent = characterName;
    }
    
    // Show modal
    const modalElement = document.getElementById('characterDetailModal');
    if (modalElement && typeof bootstrap !== 'undefined') {
        // Dispose of existing modal instance if it exists
        if (characterModal) {
            characterModal.dispose();
        }
        
        // Create new modal instance
        characterModal = new bootstrap.Modal(modalElement, {
            backdrop: true,
            keyboard: true,
            focus: true
        });
        
        // Add event listener to clean up when modal is hidden
        modalElement.addEventListener('hidden.bs.modal', function() {
            if (characterModal) {
                characterModal.dispose();
                characterModal = null;
            }
        }, { once: true }); // Use once: true so the listener is removed after firing
        
        characterModal.show();
        
        // Set up character lines loading when accordion is expanded
        setupCharacterLinesLoading(character.name);
    }
}

// Also add a function to ensure modal cleanup on page unload
document.addEventListener('DOMContentLoaded', function() {
    // Clean up modal on page unload
    window.addEventListener('beforeunload', function() {
        if (characterModal) {
            characterModal.dispose();
            characterModal = null;
        }
    });
    
    // Also add a fallback cleanup function that can be called manually
    window.cleanupCharacterModal = function() {
        const modalElement = document.getElementById('characterDetailModal');
        if (modalElement) {
            // Remove any lingering backdrop
            const backdrops = document.querySelectorAll('.modal-backdrop');
            backdrops.forEach(backdrop => backdrop.remove());
            
            // Remove modal-open class from body
            document.body.classList.remove('modal-open');
            
            // Reset body styles
            document.body.style.overflow = '';
            document.body.style.paddingRight = '';
        }
        
        if (characterModal) {
            characterModal.dispose();
            characterModal = null;
        }
    };
})

function generateCharacterDetailHTML(character, csvData, connections, connectionsByStrength, sceneAnalysis) {
    const hasImage = csvData && csvData.image && csvData.image.trim() !== '';
    const hasDescription = csvData && csvData.description && csvData.description.trim() !== '';
    const hasNotes = csvData && csvData.notes && csvData.notes.trim() !== '';

    // Fix image path - remove duplicate 'objects/' if present
    const imagePath = hasImage ? csvData.image.replace(/^objects\//, '') : '';

    // Encode character name for URL
    const encodedCharacter = encodeURIComponent(character.name);

    // Generate narrative description
    const sceneCount = character.scenesList ? character.scenesList.length : 0;
    const actsList = sceneAnalysis.acts.join(', ');

    // Create prose description of appearances
    let appearanceText = '';
    if (sceneCount > 0) {
        const scenes = character.scenesList || [];
        if (sceneCount === 1) {
            appearanceText = `appearing in ${generateSceneLink(scenes[0])}`;
        } else if (sceneCount === 2) {
            appearanceText = `appearing in ${generateSceneLink(scenes[0])} and ${generateSceneLink(scenes[1])}`;
        } else {
            const sceneLinks = scenes.map((s, i) => {
                if (i === scenes.length - 1) return `and ${generateSceneLink(s)}`;
                return generateSceneLink(s);
            });
            appearanceText = `appearing in ${sceneLinks.join(', ')}`;
        }
    }

    // Create prose for connections
    let connectionText = '';
    if (connections.length > 0) {
        const strongConnections = connectionsByStrength.strong || [];
        if (strongConnections.length > 0) {
            const names = strongConnections.map(c => c.character).slice(0, 3);
            if (names.length === 1) {
                connectionText = `most closely associated with ${names[0]}`;
            } else if (names.length === 2) {
                connectionText = `most closely associated with ${names[0]} and ${names[1]}`;
            } else {
                const last = names.pop();
                connectionText = `most closely associated with ${names.join(', ')}, and ${last}`;
            }
        } else if (connections.length <= 3) {
            const names = connections.map(c => c.character);
            connectionText = `sharing scenes with ${names.join(', ')}`;
        } else {
            connectionText = `sharing scenes with ${connections.length} other characters`;
        }
    }

    return `
        <div class="folio-character-page">
            ${hasImage ? `
                <div class="character-portrait">
                    <img src="{{ site.baseurl }}/objects/${imagePath}" alt="${character.name}">
                </div>
            ` : ''}

            <div class="character-description">
                <p class="character-intro">
                    <span class="drop-cap">${character.name.charAt(0)}</span><span class="character-name-rest">${character.name.slice(1).toUpperCase()}</span>${hasDescription ? `, ${csvData.description.toLowerCase()}` : ''}${appearanceText ? `, ${appearanceText}` : ''}.${connectionText ? ` This character is ${connectionText}.` : ''}
                </p>

                ${sceneCount > 0 ? `
                    <p class="scene-narrative">
                        Throughout the course of the drama, this character speaks in ${sceneCount} scene${sceneCount !== 1 ? 's' : ''} across Act${sceneAnalysis.acts.length > 1 ? 's' : ''} ${actsList}, encompassing the range from ${sceneAnalysis.sceneRange}.
                    </p>
                ` : ''}

                ${connections.length > 0 ? `
                    <p class="connections-narrative">
                        <em>Of the character's associations:</em> ${generateConnectionsProse(connectionsByStrength)}
                    </p>
                ` : ''}

                ${hasNotes ? `
                    <p class="character-notes">
                        <em>Further notes:</em> ${csvData.notes}
                    </p>
                ` : ''}

                <div class="character-actions">
                    <p class="action-link">
                        <a href="{{ site.baseurl }}/script.html?player=${encodedCharacter}" class="view-lines-link">
                            âš˜ View all spoken lines in the playscript
                        </a>
                    </p>
                </div>
            </div>
        </div>
    `;
}

function generateSceneLink(scene) {
    const [act, sceneNum] = scene.split('.');
    const sceneFilter = `${act}.${sceneNum}`;
    return `<a href="{{ site.baseurl }}/script.html?scene=${encodeURIComponent(sceneFilter)}" class="scene-link">Act ${act}, Scene ${sceneNum}</a>`;
}

function generateConnectionsProse(connectionsByStrength) {
    let prose = [];

    if (connectionsByStrength.strong && connectionsByStrength.strong.length > 0) {
        const names = connectionsByStrength.strong.map(c => c.character);
        if (names.length === 1) {
            prose.push(`strong bonds with ${names[0]}`);
        } else {
            const last = names.pop();
            prose.push(`strong bonds with ${names.join(', ')}, and ${last}`);
        }
    }

    if (connectionsByStrength.medium && connectionsByStrength.medium.length > 0) {
        const count = connectionsByStrength.medium.length;
        prose.push(`moderate acquaintance with ${count} other${count !== 1 ? 's' : ''}`);
    }

    if (connectionsByStrength.weak && connectionsByStrength.weak.length > 0) {
        const count = connectionsByStrength.weak.length;
        prose.push(`passing encounters with ${count} additional character${count !== 1 ? 's' : ''}`);
    }

    if (prose.length === 0) return 'no recorded interactions.';
    if (prose.length === 1) return prose[0] + '.';
    if (prose.length === 2) return prose.join('; and ') + '.';

    const last = prose.pop();
    return prose.join('; ') + '; and ' + last + '.';
}

function generateSceneGrid(scenes) {
    if (!scenes || scenes.length === 0) {
        return '<div class="col-12"><p class="text-muted">No scenes found</p></div>';
    }

    return scenes.map(scene => {
        // Parse scene to create filter URL
        const [act, sceneNum] = scene.split('.');
        const sceneFilter = `${act}.${sceneNum}`;
        return `<div class="col-auto mb-2">
            <a href="{{ site.baseurl }}/script.html?scene=${encodeURIComponent(sceneFilter)}"
               class="badge bg-primary text-decoration-none"
               title="View scene ${scene} in playscript">${scene}</a>
        </div>`;
    }).join('');
}

function generateConnectionsHTML(connectionsByStrength) {
    let html = '';
    
    if (connectionsByStrength.strong.length > 0) {
        html += `
            <div class="mb-3">
                <h6 class="text-success">Strong Connections (3+ scenes)</h6>
                <div class="row">
                    ${connectionsByStrength.strong.map(conn => 
                        `<div class="col-md-6 mb-2">
                            <div class="d-flex justify-content-between align-items-center">
                                <span><strong>${conn.character}</strong></span>
                                <span class="badge bg-success">${conn.connectionStrength}</span>
                            </div>
                            <small class="text-muted">Scenes: ${conn.sharedScenes.join(', ')}</small>
                        </div>`
                    ).join('')}
                </div>
            </div>
        `;
    }
    
    if (connectionsByStrength.medium.length > 0) {
        html += `
            <div class="mb-3">
                <h6 class="text-warning">Medium Connections (2 scenes)</h6>
                <div class="row">
                    ${connectionsByStrength.medium.map(conn => 
                        `<div class="col-md-6 mb-2">
                            <div class="d-flex justify-content-between align-items-center">
                                <span><strong>${conn.character}</strong></span>
                                <span class="badge bg-warning">${conn.connectionStrength}</span>
                            </div>
                            <small class="text-muted">Scenes: ${conn.sharedScenes.join(', ')}</small>
                        </div>`
                    ).join('')}
                </div>
            </div>
        `;
    }
    
    if (connectionsByStrength.weak.length > 0) {
        html += `
            <div class="mb-3">
                <h6 class="text-secondary">Weak Connections (1 scene)</h6>
                <div class="row">
                    ${connectionsByStrength.weak.map(conn => 
                        `<div class="col-md-6 mb-2">
                            <div class="d-flex justify-content-between align-items-center">
                                <span><strong>${conn.character}</strong></span>
                                <span class="badge bg-secondary">${conn.connectionStrength}</span>
                            </div>
                            <small class="text-muted">Scenes: ${conn.sharedScenes.join(', ')}</small>
                        </div>`
                    ).join('')}
                </div>
            </div>
        `;
    }
    
    if (html === '') {
        html = '<p class="text-muted">No connections found</p>';
    }
    
    return html;
}

function calculateCharacterConnections(character) {
    const connections = [];
    const characterScenes = character.scenesList || [];
    
    dd_characters.forEach(otherCharacter => {
        if (otherCharacter.name === character.name) return;
        
        const otherScenes = otherCharacter.scenesList || [];
        const sharedScenes = characterScenes.filter(scene => otherScenes.includes(scene));
        
        if (sharedScenes.length > 0) {
            connections.push({
                character: otherCharacter.name,
                sharedScenes: sharedScenes,
                connectionStrength: sharedScenes.length
            });
        }
    });
    
    // Sort by connection strength
    return connections.sort((a, b) => b.connectionStrength - a.connectionStrength);
}

function categorizeConnections(connections) {
    return {
        strong: connections.filter(c => c.connectionStrength >= 3),
        medium: connections.filter(c => c.connectionStrength === 2),
        weak: connections.filter(c => c.connectionStrength === 1)
    };
}

function analyzeCharacterScenes(character) {
    const scenes = character.scenesList || [];
    const acts = [...new Set(scenes.map(scene => scene.split('.')[0]))].sort();
    
    let sceneRange = 'N/A';
    if (scenes.length > 0) {
        const sortedScenes = scenes.sort((a, b) => {
            const [actA, sceneA] = a.split('.').map(Number);
            const [actB, sceneB] = b.split('.').map(Number);
            if (actA !== actB) return actA - actB;
            return sceneA - sceneB;
        });
        
        if (sortedScenes.length === 1) {
            sceneRange = sortedScenes[0];
        } else {
            sceneRange = `${sortedScenes[0]} - ${sortedScenes[sortedScenes.length - 1]}`;
        }
    }
    
    return {
        acts: acts,
        sceneRange: sceneRange,
        totalScenes: scenes.length
    };
}

function getCharacterCSVData(characterName) {
    // Use global character CSV data loaded from Jekyll
    if (typeof window.characterCSVData !== 'undefined') {
        const characterData = window.characterCSVData.find(char => 
            char.character && char.character.toLowerCase() === characterName.toLowerCase()
        );
        
        if (characterData) {
            return {
                description: characterData.description || '',
                image: characterData.image || '',
                notes: characterData.notes || ''
            };
        }
    }
    
    return null;
}

// Export for use in other components
window.openCharacterModal = openCharacterModal;

// Setup character lines loading when accordion is expanded
function setupCharacterLinesLoading(characterName) {
    const collapseId = `characterLines${characterName.replace(/\s+/g, '')}`;
    const collapseElement = document.getElementById(collapseId);
    
    if (collapseElement) {
        collapseElement.addEventListener('show.bs.collapse', function() {
            loadCharacterLines(characterName);
        });
    }
}

// Load and display character lines
function loadCharacterLines(characterName) {
    const contentId = `characterLinesContent${characterName.replace(/\s+/g, '')}`;
    const contentElement = document.getElementById(contentId);
    
    if (!contentElement) return;
    
    // Search for character lines in the metadata
    const characterLines = extractCharacterLines(characterName);
    
    if (characterLines.length === 0) {
        contentElement.innerHTML = '<p class="text-muted">No recorded lines found for this character.</p>';
        return;
    }
    
    // Display the lines
    const linesHTML = characterLines.map((line, index) => `
        <div class="character-line mb-3 p-3 border-start border-primary border-3">
            <div class="d-flex justify-content-between align-items-start mb-2">
                <strong class="text-primary">${characterName}</strong>
                ${line.scene ? `<small class="text-muted">Scene: ${line.scene}</small>` : ''}
            </div>
            <blockquote class="mb-0">
                <p class="mb-0">${line.text}</p>
            </blockquote>
        </div>
    `).join('');
    
    contentElement.innerHTML = `
        <div class="mb-3">
            <small class="text-muted">${characterLines.length} line(s) found</small>
        </div>
        ${linesHTML}
    `;
}

// Extract character lines from metadata and transcripts
function extractCharacterLines(characterName) {
    const lines = [];
    
    // Search through CollectionBuilder metadata if available
    if (typeof cb_items !== 'undefined' && Array.isArray(cb_items)) {
        cb_items.forEach(item => {
            if (item.object_transcript) {
                const transcript = item.object_transcript.toString();
                const characterLines = findCharacterLinesInText(transcript, characterName, item.title);
                lines.push(...characterLines);
            }
        });
    }
    
    return lines;
}

// Find character lines in text using various patterns
function findCharacterLinesInText(text, characterName, source) {
    const lines = [];
    const patterns = [
        // Pattern: CHARACTER: line text
        new RegExp(`^\\s*${escapeRegExp(characterName)}\\s*[:.]\\s*(.+)$`, 'gmi'),
        // Pattern: CHARACTER\n line text
        new RegExp(`^\\s*${escapeRegExp(characterName)}\\s*\\n\\s*(.+)$`, 'gmi'),
        // Pattern: [CHARACTER] line text
        new RegExp(`^\\s*\\[\\s*${escapeRegExp(characterName)}\\s*\\]\\s*(.+)$`, 'gmi')
    ];
    
    patterns.forEach(pattern => {
        let match;
        while ((match = pattern.exec(text)) !== null) {
            const lineText = match[1].trim();
            if (lineText && lineText.length > 0) {
                lines.push({
                    text: lineText,
                    source: source,
                    scene: extractSceneFromContext(text, match.index)
                });
            }
        }
    });
    
    return lines;
}

// Extract scene information from surrounding context
function extractSceneFromContext(text, position) {
    // Look for scene markers in the surrounding text
    const beforeText = text.substring(Math.max(0, position - 200), position);
    const scenePatterns = [
        /Scene\s+(\d+(?:\.\d+)?)/i,
        /Act\s+(\d+)[\s,]*Scene\s+(\d+)/i,
        /(\d+\.\d+)/
    ];
    
    for (const pattern of scenePatterns) {
        const match = beforeText.match(pattern);
        if (match) {
            if (match[2]) {
                return `${match[1]}.${match[2]}`;
            }
            return match[1];
        }
    }
    
    return null;
}

// Escape special regex characters
function escapeRegExp(string) {
    return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}
</script>

<style>
/* 1600s Book Design for Character Modal */
#characterDetailModal .modal-dialog {
    max-width: 750px;
}

#characterDetailModal .modal-content {
    border: 0;
    border-radius: 0;
}

#characterDetailModal .modal-header {
    background: #faf8f0;
    border-bottom: 3px double #2c1810;
    font-family: 'Caslon', 'Garamond', Georgia, serif;
    text-align: center;
    padding: 2rem 1.5rem 1.5rem;
}

#characterDetailModal .modal-title {
    font-family: 'Caslon', 'Garamond', Georgia, serif;
    font-size: 1.75rem;
    font-weight: normal;
    letter-spacing: 0.15em;
    text-transform: uppercase;
    color: #2c1810;
}

#characterDetailModal .modal-body {
    background: #faf8f0;
    padding: 2.5rem 3rem;
    font-family: 'Caslon', 'Garamond', Georgia, serif;
    font-size: 1.05rem;
    line-height: 1.8;
    color: #2c1810;
}

#characterDetailModal .modal-footer {
    background: #faf8f0;
    border-top: 3px double #2c1810;
    padding: 1rem 2rem;
}

/* 1600s prose layout styling */
.folio-character-page {
    max-width: 650px;
    margin: 0 auto;
}

.character-portrait {
    float: left;
    margin: 0 2rem 1rem 0;
    width: 200px;
}

.character-portrait img {
    width: 100%;
    border: 3px solid #2c1810;
    box-shadow: 5px 5px 0 rgba(44, 24, 16, 0.15);
}

.character-description p {
    text-align: justify;
    hyphens: auto;
    margin-bottom: 1.5rem;
}

/* Drop cap for first letter */
.drop-cap {
    float: left;
    font-size: 4.5rem;
    line-height: 3.5rem;
    margin: 0.1rem 0.5rem 0 0;
    font-family: 'Caslon', 'Garamond', Georgia, serif;
    font-weight: bold;
    color: #2c1810;
}

.character-name-rest {
    font-variant: small-caps;
    letter-spacing: 0.08em;
    font-size: 1.1rem;
}

/* Scene links styled as marginal references */
.scene-link {
    color: #8b4513;
    text-decoration: none;
    font-style: italic;
    border-bottom: 1px dotted #8b4513;
}

.scene-link:hover {
    color: #2c1810;
    border-bottom: 1px solid #2c1810;
}

/* Italics for narrative emphasis */
.scene-narrative em,
.connections-narrative em,
.character-notes em {
    font-style: italic;
    color: #5a4a3a;
}

/* Action link styled as colophon */
.character-actions {
    margin-top: 2rem;
    padding-top: 1.5rem;
    border-top: 2px solid #2c1810;
    text-align: center;
}

.view-lines-link {
    color: #8b4513;
    text-decoration: none;
    font-size: 1.1rem;
    letter-spacing: 0.05em;
    font-weight: 600;
}

.view-lines-link:hover {
    color: #2c1810;
    text-decoration: underline;
}

/* Remove default button styling */
#characterDetailModal .btn-secondary {
    background: #6b6b6b;
    border: 2px solid #2c1810;
    border-radius: 0;
    color: #fff;
    font-family: 'Garamond', Georgia, serif;
    letter-spacing: 0.05em;
    padding: 0.5rem 1.5rem;
}

#characterDetailModal .btn-close {
    filter: sepia(100%) saturate(200%) brightness(70%) hue-rotate(10deg);
}
</style>
